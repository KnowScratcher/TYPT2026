<!-- this code is generated by Gemini -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Cradle - Data Analysis</title>
    <!-- JSZip for handling multiple file downloads -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #0a0a0a; color: #eee; display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0; }
        canvas { background: #000; border: 1px solid #333; border-radius: 8px; box-shadow: 0 0 30px rgba(0,0,0,0.8); max-width: 95vw; }
        .controls { background: #161616; padding: 20px; border-radius: 12px; margin-top: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px; width: 850px; border: 1px solid #222; }
        .control-group { display: flex; flex-direction: column; gap: 4px; }
        .input-row { display: flex; align-items: center; gap: 10px; }
        label { font-size: 0.7rem; color: #aaa; text-transform: uppercase; font-weight: bold; letter-spacing: 0.5px; }
        input[type="range"] { flex-grow: 1; accent-color: #00d4ff; cursor: pointer; }
        input[type="number"], select { background: #000; border: 1px solid #444; color: #00d4ff; padding: 5px; border-radius: 4px; font-family: monospace; }
        input[type="number"] { width: 85px; }
        button { grid-column: span 2; padding: 12px; background: #00d4ff; color: #000; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; text-transform: uppercase; transition: 0.2s; }
        button:hover { background: #00aacc; filter: brightness(1.2); }
        button.secondary { background: #333; color: #eee; border: 1px solid #444; }
        button.secondary:hover { background: #444; }
        .stats { margin-top: 10px; font-family: 'Courier New', monospace; color: #00d4ff; font-size: 0.9rem; }
        
        .main-action-row { grid-column: span 2; display: flex; gap: 10px; }
        .main-action-row button { grid-column: auto; flex: 1; }

        .plot-section { width: 850px; background: #111; margin-top: 20px; padding: 20px; border-radius: 12px; border: 1px solid #333; box-sizing: border-box; }
        .plot-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; border-bottom: 1px solid #222; padding-bottom: 10px; }
        .plot-controls { display: flex; gap: 15px; align-items: center; }
        .plot-canvas-container { background: #050505; border-radius: 4px; padding: 10px; border: 1px solid #222; position: relative; overflow-x: auto; }
        #plotCanvas { width: 100%; height: 350px; display: block; }
        
        .advanced-export { background: #1a1a1a; margin-top: 15px; padding: 15px; border-radius: 8px; border: 1px solid #333; }
        .export-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 10px; }
        .checkbox-list { display: flex; flex-wrap: wrap; gap: 10px; max-height: 100px; overflow-y: auto; background: #000; padding: 8px; border-radius: 4px; }
        .checkbox-item { display: flex; align-items: center; gap: 5px; font-size: 0.8rem; }
        .export-actions { margin-top: 15px; display: flex; gap: 10px; }
        .export-actions button { flex: 1; }
    </style>
</head>
<body>

    <a href="./index.html" style="color: #00d4ff;">&lt; Back to description</a>
    <canvas id="canvas"></canvas>
    <div class="stats" id="energyStats">Initializing...</div>

    <div class="controls">
        <div class="control-group" style="grid-column: span 2; align-items: center;">
            <p>Simulation Algorithm: <a href="https://zh.wikipedia.org/zh-tw/%E6%AC%A7%E6%8B%89%E6%96%B9%E6%B3%95" target="_blank" style="color: #00d4ff">Euler</a> with <a href="https://zh.wikipedia.org/zh-tw/%E9%98%BB%E5%8A%9B#%E9%AB%98%E9%80%9F%E6%99%82%E7%9A%84%E9%98%BB%E5%8A%9B" target="_blank" style="color: #00d4ff">air resistance</a>.&nbsp;&nbsp;<a href="./mag_rk4_air.html"><button id="goto_euler" class="secondary">Try RK4</button></a></p>
        </div>
        
        <!-- Time Scale -->
        <div class="control-group">
            <label>Time Scale (0.1 - 10.0)</label>
            <div class="input-row">
                <input type="range" id="timeScaleSlider" min="0.1" max="10.0" step="0.1" value="1.0">
                <input type="number" id="timeScaleNum" value="1.0" step="0.1">
            </div>
        </div>

        <!-- Num Mags -->
        <div class="control-group">
            <label>Num Magnets (1 - 15)</label>
            <div class="input-row">
                <input type="range" id="numMagsSlider" min="1" max="15" step="1" value="5">
                <input type="number" id="numMagsNum" value="5" step="1">
            </div>
        </div>

        <!-- Magnet Mass -->
        <div class="control-group">
            <label>Magnet Mass (kg) (0 - 5.0)</label>
            <div class="input-row">
                <input type="range" id="massSlider" min="0.01" max="5.0" step="0.01" value="0.25">
                <input type="number" id="massNum" value="0.25" step="0.01">
            </div>
        </div>

        <!-- Magnet Strength -->
        <div class="control-group">
            <label>Magnet Strength (k) [Log 1e-10 to 1e-4]</label>
            <div class="input-row">
                <input type="range" id="magKSlider" min="-7" max="-5" step="0.001" value="-6.514">
                <input type="number" id="magKNum">
            </div>
        </div>

        <!-- Spacing -->
        <div class="control-group">
            <label>Spacing (m) (0.05 - 1.0)</label>
            <div class="input-row">
                <input type="range" id="spacingSlider" min="0.05" max="1.0" step="0.01" value="0.1">
                <input type="number" id="spacingNum" value="0.1" step="0.01">
            </div>
        </div>

        <!-- Damping -->
        <div class="control-group">
            <label>Magnet Diameter</label>
            <div class="input-row">
                <input type="range" id="dampingSlider" min="0" max="1" step="0.01" value="0.1">
                <input type="number" id="dampingNum" value="0.1" step="0.01">
            </div>
        </div>

        <!-- Left Configuration -->
        <div class="control-group" style="background: rgba(0, 212, 255, 0.05); padding: 5px; border-radius: 4px;">
            <label style="color: #00d4ff;">Left Lifted Mags</label>
            <div class="input-row">
                <input type="range" id="liftedLeftSlider" min="0" max="5" step="1" value="1">
                <input type="number" id="liftedLeftNum" value="1" step="1">
            </div>
        </div>

        <div class="control-group" style="background: rgba(255, 51, 51, 0.05); padding: 5px; border-radius: 4px;">
            <label style="color: #ff3333;">Right Lifted Mags</label>
            <div class="input-row">
                <input type="range" id="liftedRightSlider" min="0" max="5" step="1" value="0">
                <input type="number" id="liftedRightNum" value="0" step="1">
            </div>
        </div>

        <div class="control-group" style="background: rgba(0, 212, 255, 0.05); padding: 5px; border-radius: 4px;">
            <label style="color: #00d4ff;">Left Initial Angle (deg)</label>
            <div class="input-row">
                <input type="range" id="angleLeftSlider" min="-90" max="0" step="1" value="-15">
                <input type="number" id="angleLeftNum" value="-15">
            </div>
        </div>

        <div class="control-group" style="background: rgba(255, 51, 51, 0.05); padding: 5px; border-radius: 4px;">
            <label style="color: #ff3333;">Right Initial Angle (deg)</label>
            <div class="input-row">
                <input type="range" id="angleRightSlider" min="0" max="90" step="1" value="15">
                <input type="number" id="angleRightNum" value="15">
            </div>
        </div>

        <div class="control-group" style="grid-column: span 2;">
            <label>Rod Length (m) (0 - 5.0)</label>
            <div class="input-row">
                <input type="range" id="lenSlider" min="0.05" max="5.0" step="0.05" value="0.25">
                <input type="number" id="lenNum" value="0.25" step="0.1">
            </div>
        </div>

        <div class="main-action-row">
            <button id="pauseBtn" class="secondary" onclick="togglePause()">Pause Simulation</button>
            <button onclick="resetSimulation()">Reset & Apply New Config</button>
        </div>
    </div>

    <div class="plot-section">
        <div class="plot-header">
            <label style="font-size: 1rem; color: #00d4ff;">Continuous Data Recording</label>
            <div class="plot-controls">
                <div class="control-group">
                    <label>Magnet</label>
                    <select id="plotMagnetSelect"></select>
                </div>
                <div class="control-group">
                    <label>Data Point</label>
                    <select id="plotTypeSelect">
                        <option value="angleDeg">Angle (deg)</option>
                        <option value="relX">Relative X (m)</option>
                        <option value="relY">Relative Y (m)</option>
                        <option value="vel">Velocity (m/s)</option>
                        <option value="force">Force Strength (N)</option>
                        <option value="ke">Kinetic Energy (J)</option>
                        <option value="pe">Potential Energy (J)</option>
                        <option value="te">Total Energy (J)</option>
                    </select>
                </div>
            </div>
        </div>
        <div class="plot-canvas-container">
            <canvas id="plotCanvas"></canvas>
        </div>

        <div class="advanced-export">
            <label style="color: #00d4ff; font-weight: bold; font-size: 0.9rem;">ADVANCED EXPORT</label>
            <div class="export-grid">
                <div class="control-group">
                    <label>Select Magnets</label>
                    <div class="checkbox-list" id="magnetCheckboxes"></div>
                </div>
                <div class="control-group">
                    <label>Select Data Types</label>
                    <div class="checkbox-list" id="typeCheckboxes">
                        <div class="checkbox-item"><input type="checkbox" value="angleDeg" checked> Angle</div>
                        <div class="checkbox-item"><input type="checkbox" value="relX" checked> X</div>
                        <div class="checkbox-item"><input type="checkbox" value="relY" checked> Y</div>
                        <div class="checkbox-item"><input type="checkbox" value="vel" checked> Velocity</div>
                        <div class="checkbox-item"><input type="checkbox" value="force" checked> Force</div>
                        <div class="checkbox-item"><input type="checkbox" value="ke" checked> KE</div>
                        <div class="checkbox-item"><input type="checkbox" value="pe" checked> PE</div>
                        <div class="checkbox-item"><input type="checkbox" value="te" checked> Total E</div>
                    </div>
                </div>
            </div>
            <div class="export-actions">
                <button class="secondary" onclick="downloadData('csv')">Download Multi-Channel CSV</button>
                <button onclick="downloadData('png')">Export All Selected Plots (ZIP)</button>
            </div>
        </div>
    </div>

<script>
    (function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const energyDisplay = document.getElementById('energyStats');
        const pauseBtn = document.getElementById('pauseBtn');
        
        const plotCanvas = document.getElementById('plotCanvas');
        const pctx = plotCanvas.getContext('2d');
        const plotMagnetSelect = document.getElementById('plotMagnetSelect');
        const plotTypeSelect = document.getElementById('plotTypeSelect');
        const magnetCheckboxes = document.getElementById('magnetCheckboxes');
        const typeCheckboxes = document.getElementById('typeCheckboxes');

        function setupSync(sliderId, numId, isLog = false) {
            const slider = document.getElementById(sliderId);
            const num = document.getElementById(numId);
            slider.oninput = () => {
                num.value = isLog ? Math.pow(10, slider.value).toExponential(2) : slider.value;
                if(sliderId.includes('lifted') || sliderId === 'numMagsSlider') updateSideLimits(sliderId);
            };
            num.oninput = () => {
                const val = parseFloat(num.value);
                if (isLog) {
                    slider.value = val > 0 ? Math.log10(val) : -99;
                } else {
                    slider.value = num.value;
                }
                if(numId.includes('lifted') || numId === 'numMagsNum') updateSideLimits(numId);
            };
            if(isLog) num.value = Math.pow(10, slider.value).toExponential(2);
        }

        function updateSideLimits(triggerId) {
            const nMags = parseInt(document.getElementById('numMagsNum').value);
            const lSlider = document.getElementById('liftedLeftSlider');
            const lNum = document.getElementById('liftedLeftNum');
            const rSlider = document.getElementById('liftedRightSlider');
            const rNum = document.getElementById('liftedRightNum');

            // Set max bounds for both based on total count
            lSlider.max = nMags;
            rSlider.max = nMags;

            let lVal = parseInt(lNum.value) || 0;
            let rVal = parseInt(rNum.value) || 0;

            // Logic: Left + Right <= nMags
            // If the user adjusted Left, push Right down if necessary.
            // If the user adjusted Right, push Left down if necessary.
            // If the user adjusted nMags, push both down proportionally or clamped.
            
            if (triggerId === 'liftedLeftSlider' || triggerId === 'liftedLeftNum') {
                if (lVal + rVal > nMags) {
                    rVal = nMags - lVal;
                    rNum.value = rVal;
                    rSlider.value = rVal;
                }
            } else if (triggerId === 'liftedRightSlider' || triggerId === 'liftedRightNum') {
                if (lVal + rVal > nMags) {
                    lVal = nMags - rVal;
                    lNum.value = lVal;
                    lSlider.value = lVal;
                }
            } else {
                // Total magnets changed
                if (lVal + rVal > nMags) {
                    // Simple clamp: prioritize left
                    if (lVal > nMags) {
                        lVal = nMags;
                        rVal = 0;
                    } else {
                        rVal = nMags - lVal;
                    }
                    lNum.value = lVal;
                    lSlider.value = lVal;
                    rNum.value = rVal;
                    rSlider.value = rVal;
                }
            }
        }

        setupSync('timeScaleSlider', 'timeScaleNum');
        setupSync('numMagsSlider', 'numMagsNum');
        setupSync('spacingSlider', 'spacingNum');
        setupSync('magKSlider', 'magKNum', true);
        setupSync('lenSlider', 'lenNum');
        setupSync('massSlider', 'massNum');
        setupSync('dampingSlider', 'dampingNum');
        
        setupSync('liftedLeftSlider', 'liftedLeftNum');
        setupSync('angleLeftSlider', 'angleLeftNum');
        setupSync('liftedRightSlider', 'liftedRightNum');
        setupSync('angleRightSlider', 'angleRightNum');

        let n, pixelsPerMeter, realL, mass, magK, realSpacing, g = 9.81, damping;
        let nLiftedLeft, angleLeft, nLiftedRight, angleRight;
        let magnets = [];
        let lastTimestamp = 0;
        let simTime = 0, accumulator = 0;
        let isPaused = false;
        const dt = 0.0005;

        let history = []; 
        const HISTORY_LIMIT = 100000; 
        const RECORD_INTERVAL = 0.005;

        class Magnet {
            constructor(index, angle) {
                this.index = index;
                this.angle = angle * Math.PI / 180;
                this.vel = 0;
                this.accel = 0;
                this.lastForce = 0;
                this.ke = 0;
                this.pe = 0;
                this.te = 0;
                this.relX = 0;
                this.relY = 0;
                this.angleDeg = angle;
            }
        }

        window.togglePause = function() {
            isPaused = !isPaused;
            pauseBtn.innerText = isPaused ? "Resume Simulation" : "Pause Simulation";
            pauseBtn.style.background = isPaused ? "#00d4ff" : "#333";
            pauseBtn.style.color = isPaused ? "#000" : "#eee";
        };

        window.resetSimulation = function() {
            const prevMagIdx = plotMagnetSelect.value;
            const prevTypeIdx = plotTypeSelect.value;

            n = parseInt(document.getElementById('numMagsNum').value);
            nLiftedLeft = parseInt(document.getElementById('liftedLeftNum').value);
            angleLeft = parseFloat(document.getElementById('angleLeftNum').value);
            nLiftedRight = parseInt(document.getElementById('liftedRightNum').value);
            angleRight = parseFloat(document.getElementById('angleRightNum').value);

            magK = parseFloat(document.getElementById('magKNum').value);
            realL = parseFloat(document.getElementById('lenNum').value);
            mass = parseFloat(document.getElementById('massNum').value);
            damping = parseFloat(document.getElementById('dampingNum').value);
            realSpacing = parseFloat(document.getElementById('spacingNum').value);
            
            simTime = 0;
            accumulator = 0;
            history = [];
            isPaused = false;
            pauseBtn.innerText = "Pause Simulation";
            pauseBtn.style.background = "#333";
            pauseBtn.style.color = "#eee";
            
            canvas.width = 900;
            canvas.height = 500;

            const totalWidthMeters = (n - 1) * realSpacing + (2 * realL); 
            const totalHeightMeters = realL + 0.1; 
            
            const zoomX = (canvas.width - 100) / totalWidthMeters;
            const zoomY = (canvas.height - 100) / totalHeightMeters;
            pixelsPerMeter = Math.min(zoomX, zoomY, 2000); 
            
            magnets = [];
            for(let i=0; i<n; i++) {
                let angle = 0;
                if (i < nLiftedLeft) angle = angleLeft;
                else if (i >= n - nLiftedRight) angle = angleRight;
                magnets.push(new Magnet(i, angle));
            }

            plotMagnetSelect.innerHTML = '';
            magnetCheckboxes.innerHTML = '';
            for(let i=0; i<n; i++) {
                let opt = document.createElement('option');
                opt.value = i;
                
                // Determine if lifted for labeling
                let statusLabel = "";
                if (i < nLiftedLeft) statusLabel = " (Lifted Left)";
                else if (i >= n - nLiftedRight) statusLabel = " (Lifted Right)";
                
                opt.innerText = `Magnet ${i + 1}${statusLabel}`;
                plotMagnetSelect.appendChild(opt);

                let div = document.createElement('div');
                div.className = 'checkbox-item';
                div.innerHTML = `<input type="checkbox" value="${i}" checked> Mag ${i+1}${statusLabel ? '*' : ''}`;
                magnetCheckboxes.appendChild(div);
            }

            if (prevMagIdx && parseInt(prevMagIdx) < n) plotMagnetSelect.value = prevMagIdx;
            if (prevTypeIdx) plotTypeSelect.value = prevTypeIdx;

            plotCanvas.width = plotCanvas.clientWidth * 2;
            plotCanvas.height = plotCanvas.clientHeight * 2;
        };

        function physicsStep() {
            const xPos = magnets.map((m, i) => i * realSpacing + realL * Math.sin(m.angle));
            const yPos = magnets.map((m, i) => realL * Math.cos(m.angle) - realL);
            
            magnets.forEach((m, i) => {
                let gravityAccel = -(g / realL) * Math.sin(m.angle) - (Math.sign(m.vel) * 0.5 * 1.225 * Math.pow(m.vel, 2) * 1.28 * Math.PI * Math.pow(damping, 2)) / mass;
                let totalMagForce = 0;
                for (let j = 0; j < n; j++) {
                    if (i === j) continue;
                    let r = xPos[i] - xPos[j];
                    let dist = Math.max(Math.abs(r), 0.015);
                    let force = magK / Math.pow(dist, 3.79); // change to power of 2
                    totalMagForce += (Math.sign(r) * force);// - 0.5 * 1.225 * Math.pow(m.vel, 2) * 1.28 * Math.PI * Math.pow(0.1, 2);
                }
                m.lastForce = totalMagForce;
                m.accel = gravityAccel + (totalMagForce / mass) / realL;
                
                m.pe = mass * g * realL * (1 - Math.cos(m.angle));
                m.ke = 0.5 * mass * Math.pow(realL * m.vel, 2);
                m.te = m.pe + m.ke;
                m.relX = xPos[i] - (i * realSpacing);
                m.relY = yPos[i];
                m.angleDeg = m.angle * (180 / Math.PI);
            });

            magnets.forEach(m => {
                m.vel += m.accel * dt;
                m.angle += m.vel * dt;
            });

            if (Math.floor(simTime / RECORD_INTERVAL) > Math.floor((simTime - dt) / RECORD_INTERVAL)) {
                history.push({
                    time: simTime,
                    data: magnets.map(m => ({
                        relX: m.relX,
                        relY: m.relY,
                        vel: m.vel,
                        force: m.lastForce,
                        ke: m.ke,
                        pe: m.pe,
                        te: m.te,
                        angleDeg: m.angleDeg
                    }))
                });
                if (history.length > HISTORY_LIMIT) history.shift(); 
            }
            simTime += dt;
        }

        function drawPlot(specificMag = null, specificType = null, targetCtx = null) {
            if (history.length < 2) return;
            const magIdx = specificMag !== null ? specificMag : parseInt(plotMagnetSelect.value);
            const prop = specificType !== null ? specificType : plotTypeSelect.value;
            const activeCtx = targetCtx || pctx;

            const padding = { top: 70, right: 40, bottom: 80, left: 115 };
            const w = plotCanvas.width;
            const h = plotCanvas.height;
            const innerW = w - padding.left - padding.right;
            const innerH = h - padding.top - padding.bottom;

            activeCtx.fillStyle = '#ffffff';
            activeCtx.fillRect(0, 0, w, h);

            const timeMin = history[0].time;
            const timeMax = history[history.length - 1].time;
            let valMin = Infinity, valMax = -Infinity;
            history.forEach(h => {
                const v = h.data[magIdx][prop];
                if (v < valMin) valMin = v;
                if (v > valMax) valMax = v;
            });
            const range = valMax - valMin;
            valMin -= range * 0.1 || 0.1;
            valMax += range * 0.1 || 0.1;

            const getX = (t) => padding.left + ((t - timeMin) / (timeMax - timeMin)) * innerW;
            const getY = (v) => padding.top + innerH - ((v - valMin) / (valMax - valMin)) * innerH;

            activeCtx.fillStyle = '#000';
            activeCtx.font = 'bold 24px Segoe UI';
            activeCtx.textAlign = 'center';
            const propLabel = specificType ? prop : plotTypeSelect.options[plotTypeSelect.selectedIndex].text;
            activeCtx.fillText(`Magnet ${magIdx + 1}: ${propLabel}`, w / 2, 35);

            if (valMin <= 0 && valMax >= 0) {
                const zeroY = getY(0);
                activeCtx.strokeStyle = '#ff4444';
                activeCtx.lineWidth = 1.5;
                activeCtx.setLineDash([5, 5]);
                activeCtx.beginPath(); activeCtx.moveTo(padding.left, zeroY); activeCtx.lineTo(w - padding.right, zeroY); activeCtx.stroke();
                activeCtx.setLineDash([]);
            }

            activeCtx.strokeStyle = '#ddd';
            activeCtx.fillStyle = '#888';
            activeCtx.font = '16px monospace';
            for(let i=0; i<=5; i++) {
                let v = valMin + (i/5) * (valMax - valMin);
                let y = getY(v);
                activeCtx.beginPath(); activeCtx.moveTo(padding.left, y); activeCtx.lineTo(w - padding.right, y); activeCtx.stroke();
                activeCtx.textAlign = 'right';
                activeCtx.fillText(v.toExponential(2), padding.left - 15, y + 6);
            }
            for(let i=0; i<=5; i++) {
                let t = timeMin + (i/5) * (timeMax - timeMin);
                let x = getX(t);
                activeCtx.beginPath(); x && activeCtx.moveTo(x, padding.top); x && activeCtx.lineTo(x, h - padding.bottom); activeCtx.stroke();
                activeCtx.textAlign = 'center';
                activeCtx.fillText(t.toFixed(1) + "s", x, h - padding.bottom + 25);
            }

            activeCtx.fillStyle = '#00d4ff';
            activeCtx.font = 'bold 22px Segoe UI';
            activeCtx.textAlign = 'center';
            activeCtx.fillText("Time (seconds)", padding.left + innerW / 2, h - 20);
            
            activeCtx.save();
            activeCtx.translate(30, padding.top + innerH / 2);
            activeCtx.rotate(-Math.PI / 2);
            activeCtx.fillText(propLabel, 0, -10);
            activeCtx.restore();

            activeCtx.strokeStyle = '#00d4ff';
            activeCtx.lineWidth = 2.5;
            activeCtx.beginPath();
            history.forEach((point, i) => {
                const x = getX(point.time);
                const y = getY(point.data[magIdx][prop]);
                if (i === 0) activeCtx.moveTo(x, y); else activeCtx.lineTo(x, y);
            });
            activeCtx.stroke();
        }

        window.downloadData = async function(format) {
            if (history.length < 2) return;
            const selectedMags = Array.from(magnetCheckboxes.querySelectorAll('input:checked')).map(i => parseInt(i.value));
            const selectedTypes = Array.from(typeCheckboxes.querySelectorAll('input:checked')).map(i => i.value);
            if(selectedMags.length === 0 || selectedTypes.length === 0) return;

            if (format === 'csv') {
                let csvRows = [];
                let header = ['Time(s)'];
                selectedMags.forEach(m => selectedTypes.forEach(t => header.push(`${m+1}-${t}`)));
                csvRows.push(header.join(','));
                history.forEach(h => {
                    let row = [h.time.toFixed(4)];
                    selectedMags.forEach(m => selectedTypes.forEach(t => row.push(h.data[m][t])));
                    csvRows.push(row.join(','));
                });
                const blob = new Blob([csvRows.join('\n')], { type: 'text/csv' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `mcd_${n}mag_lift-l${angleLeft}x${nLiftedLeft}-r${angleRight}x${nLiftedRight}_l${realL}_s${realSpacing}_${simTime.toFixed(1)}s.csv`;
                a.click();
            } else {
                const zip = new JSZip();
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = plotCanvas.width;
                tempCanvas.height = plotCanvas.height;
                const tctx = tempCanvas.getContext('2d');
                for (let m of selectedMags) {
                    for (let t of selectedTypes) {
                        drawPlot(m, t, tctx);
                        zip.file(`mag${m+1}_${t}.png`, tempCanvas.toDataURL('image/png').split(',')[1], {base64: true});
                    }
                }
                const content = await zip.generateAsync({type: 'blob'});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(content);
                a.download = `mcp_${n}mag_lift-l${angleLeft}x${nLiftedLeft}-r${angleRight}x${nLiftedRight}_l${realL}_s${realSpacing}_${simTime.toFixed(1)}s.zip`;
                a.click();
                drawPlot();
            }
        };

        function draw(timestamp) {
            if (!lastTimestamp) lastTimestamp = timestamp;
            let frameTime = Math.min((timestamp - lastTimestamp) / 1000, 0.1); 
            lastTimestamp = timestamp;

            if (!isPaused) {
                const timeScale = parseFloat(document.getElementById('timeScaleNum').value);
                accumulator += frameTime * timeScale;
                while (accumulator >= dt) { physicsStep(); accumulator -= dt; }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const centerX = canvas.width / 2;
            const centerY = (canvas.height - (realL * pixelsPerMeter)) / 2;
            let totalKE = 0, totalPE = 0;

            magnets.forEach((m) => {
                const visualSpacing = realSpacing * pixelsPerMeter;
                const totalWidth = (n - 1) * visualSpacing;
                const pivotX = centerX - totalWidth / 2 + (m.index * visualSpacing);
                const x = pivotX + (realL * pixelsPerMeter) * Math.sin(m.angle);
                const y = centerY + (realL * pixelsPerMeter) * Math.cos(m.angle);

                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(pivotX, centerY); ctx.lineTo(x, y); ctx.stroke();

                ctx.fillStyle = (m.index < parseInt(document.getElementById('liftedLeftNum').value)) ? '#00d4ff' : 
                               (m.index >= n - parseInt(document.getElementById('liftedRightNum').value)) ? '#ff3333' : '#777';
                ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI * 2); ctx.fill();
                ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
                totalPE += m.pe; totalKE += m.ke;
            });

            energyDisplay.innerText = `${isPaused ? '[PAUSED] ' : ''}KE: ${totalKE.toFixed(4)}J | PE: ${totalPE.toFixed(4)}J | Time: ${simTime.toFixed(2)}s`;
            drawPlot();
            requestAnimationFrame(draw);
        }

        resetSimulation();
        requestAnimationFrame(draw);
    })();
</script>
</body>
</html>